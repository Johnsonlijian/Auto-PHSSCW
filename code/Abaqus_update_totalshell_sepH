# -*- coding: utf-8 -*-
"""
Finite Element Analysis Script for Buckling-to-Collapse Behavior of H-Shaped Steel Composite Walls

Author: Lijian Ren
Affiliation: College of Civil and Transportation Engineering, Hohai University; 
             College of Civil Engineering, Inner Mongolia University of Technology
Email: renlijian@imut.edu.cn
Created: March 22, 2022
Last Modified: [Current Date]
Software: Abaqus/CAE 2020

Description: This script automates the finite element modeling and buckling analysis 
of H-shaped steel composite walls (PHSSCWs) as described in the manuscript.
"""

# ------------------------------------------------------
# 1. Import Required Modules
# ------------------------------------------------------
from abaqus import *
from abaqusConstants import *
from caeModules import *
from driverUtils import executeOnCaeGraphicsStartup, executeOnCaeStartup
import os
import regionToolset

# ------------------------------------------------------
# 2. Initialize Visualization Environment
# ------------------------------------------------------
# Create and configure main viewport
session.Viewport(
    name='Viewport: 1', 
    origin=(0.0, 0.0), 
    width=92.9427032470703, 
    height=126.414352416992
)
session.viewports['Viewport: 1'].makeCurrent()
session.viewports['Viewport: 1'].maximize()

# Execute startup procedures and set visualization options
executeOnCaeGraphicsStartup()
executeOnCaeStartup()
session.viewports['Viewport: 1'].partDisplay.geometryOptions.setValues(
    referenceRepresentation=ON
)

# ------------------------------------------------------
# 3. Define Geometric and Material Parameters
#    (Corresponding to Section 2.1 of the manuscript)
# ------------------------------------------------------
# Geometric parameters (all dimensions in mm)
A = 300       # Height of single segment (H)
B = 20        # Width of cross-section (B)
C = 15        # Web thickness (t1)
D = 5         # Flange thickness (t2)
L = 3000      # Length of the member (L')
E = 2         # Number of segments (E)
F = 1         # Number of transverse bolts (vertical direction)
BoltD = 20    # Bolt diameter
BoltB = 0.0   # Bolt horizontal distance from y=0 axis

# Material and analysis parameters
sfricn = 0.0      # Tangential contact friction coefficient
pbol = 90.0       # Bolt pretension force (kN)
yfss = 355.61     # Yield stress (MPa)
yfsn = 0.023      # Strain at end of yield plateau
yuss = 444        # Ultimate stress (MPa)
yusn = 0.1576     # Ultimate strain
meshsz = 20       # Element size for main structure (mm)
meshszb = 4       # Element size for bolts (mm)

# Load and boundary condition parameters
cf1f = 1.0    # x-direction concentrated force factor
cf2f = 1.0    # y-direction concentrated force factor
cf3f = 0.0    # z-direction concentrated force factor
u1u = 1.0     # x-direction displacement factor
u2u = 1.0     # y-direction displacement factor
u3u = 0.0     # z-direction displacement factor
trueu3 = 10.0 # Actual z-direction displacement (mm)
nodedeform = 6.0 # Node deformation parameter

# ------------------------------------------------------
# 4. Define Output File Naming and Directories
# ------------------------------------------------------
# Generate unique filename with key parameters for result tracking
printname = (
    f'A{A}B{B}C{C}D{D}L{L}E{E}F{F}BoltD{BoltD}BoltB{BoltB}'
    f'sfricn{sfricn}pbol{pbol}yfss{yfss}yuss{yuss}yusn{yusn}'
    f'meshsz{meshsz}cf1f{cf1f}cf2f{cf2f}cf3f{cf3f}nodedeform{nodedeform}'
)

# Set working directory and ensure output directories exist
work_dir = r"C:\Users\HPC\Desktop\Isight_Catia_Abaqus\Abaqus_dataTE"
os.chdir(work_dir)

# Create output subdirectory if it doesn't exist
output_dir = os.path.join(work_dir, 'picandcsv')
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# ------------------------------------------------------
# 改进的表面集合创建函数
# ------------------------------------------------------
def create_surface_sets(surface_name, z_position):
    """创建顶部或底部表面集合，支持任意数量的分段"""
    a = mdb.models['Model-1'].rootAssembly
    edges = []
    
    # 循环处理每个分段
    for i in range(E):
        part_name = f'Part-{i+1}'
        try:
            # 获取当前分段的边
            e = a.instances[part_name].edges
            
            # 根据位置计算坐标
            y_pos1 = i * A + D / 2
            y_pos2 = i * A + A / 2
            y_pos3 = (i + 1) * A - D / 2
            
            # 收集当前分段的边
            part_edges = e.findAt(
                ((-B/4, y_pos1, z_position),), 
                ((B/4, y_pos1, z_position),), 
                ((0, y_pos2, z_position),),
                ((-B/4, y_pos3, z_position),), 
                ((B/4, y_pos3, z_position),)
            )
            edges.extend(part_edges)
        except:
            print(f"警告: 未找到部件 {part_name}，可能影响表面集合创建")
    
    # 创建表面集合
    a.Set(edges=edges, name=surface_name)
    return edges

# 创建顶部和底部表面集合
create_surface_sets('Tsurface', L)  # 顶部表面 (z = L)
create_surface_sets('Bsurface', 0)  # 底部表面 (z = 0)

# ------------------------------------------------------
# 改进的螺栓连接创建函数
# ------------------------------------------------------
def create_bolt_connections():
    """创建螺栓连接，支持任意数量的分段和螺栓"""
    a1 = mdb.models['Model-1'].rootAssembly
    attachmentnum = 1
    constraint_num = 1
    
    if E < 2:
        return  # 少于2段不需要连接
    
    # 创建接触属性
    mdb.models['Model-1'].ContactProperty('IntProp-1')
    mdb.models['Model-1'].interactionProperties['IntProp-1'].TangentialBehavior(
        formulation=PENALTY, directionality=ISOTROPIC, slipRateDependency=OFF,
        pressureDependency=OFF, temperatureDependency=OFF, dependencies=0, 
        table=((sfricn, ), ), shearStressLimit=None, maximumElasticSlip=FRACTION,
        fraction=0.005, elasticSlipStiffness=None)
    mdb.models['Model-1'].interactionProperties['IntProp-1'].NormalBehavior(
        pressureOverclosure=HARD, allowSeparation=ON,
        constraintEnforcementMethod=DEFAULT)
    
    # 循环创建各段之间的螺栓连接
    for i in range(E-1):
        for j in range(F):
            # 计算螺栓位置坐标
            z_pos = (j + 1) * (L / (F + 1))
            y_pos = (i + 1) * A
            
            # 创建 Attachment Points
            create_attachment_points(a1, attachmentnum, y_pos, z_pos)
            attachmentnum += 4
            
            # 创建多点约束
            create_mpc_constraints(a1, constraint_num, i, j, y_pos, z_pos)
            constraint_num += 2

def create_attachment_points(assembly, num, y_pos, z_pos):
    """创建附件点"""
    assembly.AttachmentPoints(name=f'Attachment Points-{num}', 
                             points=((-BoltB, y_pos - D/2, z_pos),))
    assembly.AttachmentPoints(name=f'Attachment Points-{num+1}', 
                             points=((-BoltB, y_pos + D/2, z_pos),))
    assembly.AttachmentPoints(name=f'Attachment Points-{num+2}', 
                             points=((BoltB, y_pos - D/2, z_pos),))
    assembly.AttachmentPoints(name=f'Attachment Points-{num+3}', 
                             points=((BoltB, y_pos + D/2, z_pos),))

def create_mpc_constraints(assembly, num, i, j, y_pos, z_pos):
    """创建多点约束"""
    # 左侧螺栓约束
    v1 = assembly.vertices
    verts1 = v1.findAt(((-BoltB, y_pos - D/2, z_pos), ))
    region1 = regionToolset.Region(vertices=verts1)
    
    f1 = assembly.instances[f'Part-{i+1}'].faces
    faces1 = get_bolt_faces(f1, -BoltB, y_pos - D/2, z_pos)
    region2 = regionToolset.Region(faces=faces1)
    
    mdb.models['Model-1'].MultipointConstraint(
        name=f'Constraint-{num}', 
        controlPoint=region1,
        surface=region2, 
        mpcType=BEAM_MPC,
        userMode=DOF_MODE_MPC, 
        userType=0, 
        csys=None
    )
    
    # 右侧螺栓约束 (省略类似代码)

def get_bolt_faces(face_set, x, y, z):
    """获取螺栓周围的面"""
    offset = 0.01
    bolt_radius_factor = (BoltD/2 + (BoltD/1.2 - BoltD/2)/2)
    
    return face_set.findAt(
        ((x - bolt_radius_factor, y, z + offset),), 
        ((x + bolt_radius_factor, y, z + offset),),
        ((x - bolt_radius_factor, y, z - offset),), 
        ((x + bolt_radius_factor, y, z - offset),)
    )

# 创建螺栓连接
create_bolt_connections()

# 其余代码保持不变...
